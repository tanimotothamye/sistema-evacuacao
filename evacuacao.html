<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>SafeRoute - Evacuação</title>
    
    <link rel="stylesheet" href="style.css">
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />

    <style>
        /* Estilos adicionais e overrides para evacuacao.html */
        body {
            /* ESTAS REGRAS SÃO CRÍTICAS para garantir que a página de evacuação funcione corretamente,
               MESMO SE O style.css GERAL TIVER REGRAS DE 'overflow: hidden;' ou 'display: flex' */
            display: block !important; /* Força o comportamento de bloco para o body */
            justify-content: unset !important; /* Remove alinhamento flexível herdado */
            align-items: unset !important; /* Remove alinhamento flexível herdado */
            
            overflow-y: auto !important; /* Permite rolagem vertical */
            overflow-x: hidden !important; /* Esconde rolagem horizontal */
            height: auto !important; /* Altura se adapta ao conteúdo */
            min-height: 100vh !important; /* Garante altura mínima da viewport */
            
            padding-top: 20px !important; /* Garante que o conteúdo comece do topo */
            color: white; /* Garante cor do texto branca */
            text-shadow: 1px 1px 3px black; /* Garante sombra no texto */
        }

        /* Blobs decorativos - estilos já estão no style.css, mas se precisar de overrides específicos: */
        .blob {
            z-index: -1; /* Atrás do conteúdo */
        }

        /* Container Glassmorphism */
        .evacuation-container {
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 1200px;
            margin: 30px auto; 
            text-align: center; 
        }
        
        h1, h2, h3 {
            color: #fff;
            text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        h2 {
            font-size: 1.8rem;
            margin-bottom: 30px;
        }

        #evacuation-map {
            width: 100%;
            height: 500px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            margin-bottom: 30px;
        }
        
        .shelter-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
            justify-content: center; 
        }
        
        .shelter-card {
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s ease;
            text-align: left; 
        }
        
        .shelter-card:hover {
            transform: translateY(-5px);
        }
        
        .shelter-card h3 {
            color: #fff;
            margin-bottom: 10px;
            font-size: 1.5rem;
        }
        
        .shelter-card p {
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 8px;
            font-size: 0.95rem;
        }
        
        .shelter-card .distance {
            font-weight: 600;
            color: #7afcff;
        }
        
        .shelter-card .capacity {
            font-weight: 600;
            color: #feff9c;
        }
        
        .route-btn {
            background: rgba(255, 126, 179, 0.3);
            display: block;
            width: 100%;
            padding: 12px;
            border: none; 
            border-radius: 8px;
            text-align: center;
            margin-top: 15px;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.2s ease;
            color: white;
            font-size: 1rem;
            text-decoration: none; 
        }
        
        .route-btn:hover {
            background: rgba(255, 126, 179, 0.5);
            transform: translateY(-2px);
        }

        button {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.2s ease;
            margin-top: 40px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-3px);
        }
    </style>
</head>
<body>
    <div class="blob blob1"></div>
    <div class="blob blob2"></div>
    <div class="blob blob3"></div>

    <div class="evacuation-container">
        <h1>Rotas de Evacuação</h1>
        <h2>Encontre o abrigo mais próximo de você</h2>
        
        <div id="evacuation-map"></div>
        
        <h3>Abrigos disponíveis</h3>
        <div class="shelter-list" id="shelter-list-container">
            </div>
        
        <button onclick="window.location.href='PaginaInicial.html'" style="margin-top: 40px;">
            <i class="fas fa-arrow-left"></i> Voltar
        </button>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>
    <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script>
    
    <script>
        let map; 
        let userLocation = null; // Armazena a localização do usuário (L.LatLng)
        let routingControl = null; // Para armazenar a rota e poder removê-la

        // Lista de nomes de abrigos para usar dinamicamente
        const shelterNames = [
            "Escola Municipal",
            "Ginásio Esportivo",
            "Centro Comunitário",
            "Quartel Policial",
            "Igreja Central",
            "Parque de Exposições",
            "Clube Recreativo",
            "Biblioteca Pública"
        ];
        let nameIndex = 0; // Para ciclar pelos nomes

        // Função para gerar abrigos com localizações aleatórias e nomes descritivos
        function generateRandomShelters(centerLat, centerLng, numberOfShelters = 3, maxOffsetKm = 5) {
            const shelters = [];
            const latKmPerDegree = 111; 
            const lngKmPerDegree = 111 * Math.cos(centerLat * Math.PI / 180); 

            for (let i = 0; i < numberOfShelters; i++) {
                const offsetX = (Math.random() * 2 - 1) * maxOffsetKm; 
                const offsetY = (Math.random() * 2 - 1) * maxOffsetKm;

                const newLat = centerLat + (offsetY / latKmPerDegree);
                const newLng = centerLng + (offsetX / lngKmPerDegree);

                // Pega um nome da lista e avança o índice (ciclando)
                const name = shelterNames[nameIndex % shelterNames.length];
                nameIndex++; 

                shelters.push({
                    name: name,
                    lat: newLat,
                    lng: newLng,
                    capacity: Math.floor(Math.random() * (500 - 100 + 1)) + 100, // Capacidade aleatória
                });
            }
            return shelters;
        }

        // Função para calcular a distância entre dois pontos (Haversine)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Raio da Terra em quilômetros
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distance = R * c; 
            return distance.toFixed(2); 
        }

        // Função para popular as informações dos abrigos no HTML e no mapa
        function populateShelters(mapInstance, sheltersArray, currentUserLocation) {
            const shelterListContainer = document.getElementById('shelter-list-container');
            shelterListContainer.innerHTML = ''; // Limpa a lista existente

            sheltersArray.forEach(shelter => {
                // Adiciona marcador ao mapa
                L.marker([shelter.lat, shelter.lng])
                    .addTo(mapInstance)
                    .bindPopup(shelter.name);

                // Cria o card do abrigo para o HTML
                const shelterCard = document.createElement('div');
                shelterCard.className = 'shelter-card';
                shelterCard.innerHTML = `
                    <h3>${shelter.name}</h3>
                    <p><span class="distance">${calculateDistance(currentUserLocation.lat, currentUserLocation.lng, shelter.lat, shelter.lng)} km</span> de distância</p>
                    <p>Capacidade: <span class="capacity">${shelter.capacity} pessoas</span></p>
                    <button class="route-btn" data-lat="${shelter.lat}" data-lng="${shelter.lng}">Mostrar Rota</button> 
                `;
                shelterListContainer.appendChild(shelterCard);
            });

            // Reconfigura os ouvintes de evento para os novos botões
            setupRoutingButtons(mapInstance);
        }

        window.onload = function() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    function(position) {
                        userLocation = L.latLng(position.coords.latitude, position.coords.longitude);
                        
                        console.log("Localização real obtida (evacuacao.html):", userLocation.lat, userLocation.lng); 
                        
                        map = L.map('evacuation-map').setView(userLocation, 13); 
                        
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            maxZoom: 19,
                            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                        }).addTo(map);
                        
                        // Adicionar marcador da localização do usuário
                        L.marker(userLocation)
                            .addTo(map)
                            .bindPopup('Você está aqui!')
                            .openPopup();
                            
                        // Gerar abrigos aleatórios próximos à localização do usuário
                        // 3 abrigos em até 5km da localização do usuário
                        const shelters = generateRandomShelters(userLocation.lat, userLocation.lng, 3, 5); 
                        populateShelters(map, shelters, userLocation);

                    },
                    function(error) {
                        // Alerta para erro ao obter localização
                        alert(`Não foi possível obter sua localização (erro: ${error.message}). Por favor, verifique as permissões do navegador. Usando localização padrão (Brasília).`);
                        console.error("Erro de geolocalização (evacuacao.html):", error);
                        
                        // Fallback para coordenadas de Brasília se o acesso à localização for negado
                        userLocation = L.latLng(-15.7942, -47.8822); // Coordenadas de Brasília como fallback
                        map = L.map('evacuation-map').setView(userLocation, 13);
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

                        // Adicionar marcador da localização padrão
                        L.marker(userLocation)
                            .addTo(map)
                            .bindPopup('Localização padrão (Brasília)');

                        // Gerar abrigos aleatórios próximos à localização padrão
                        const sheltersFallback = generateRandomShelters(userLocation.lat, userLocation.lng, 3, 5);
                        populateShelters(map, sheltersFallback, userLocation);
                    }
                );
            } else {
                // Alerta para navegador sem suporte a geolocalização
                alert("Seu navegador não suporta geolocalização ou ela está desativada. Usando localização padrão (Brasília).");
                
                // Default para coordenadas de Brasília
                userLocation = L.latLng(-15.7942, -47.8822);
                map = L.map('evacuation-map').setView(userLocation, 13);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

                // Adicionar marcador da localização padrão
                L.marker(userLocation)
                    .addTo(map)
                    .bindPopup('Localização padrão (Brasília)');

                // Gerar abrigos aleatórios próximos à localização padrão
                const sheltersFallback = generateRandomShelters(userLocation.lat, userLocation.lng, 3, 5);
                populateShelters(map, sheltersFallback, userLocation);
            }
        };

        // A função setupRoutingButtons agora usa a variável global userLocation
        function setupRoutingButtons(mapInstance) {
            const routeButtons = document.querySelectorAll('.route-btn');
            routeButtons.forEach(button => {
                // Remove qualquer ouvinte de evento anterior para evitar duplicação
                button.removeEventListener('click', handleRouteButtonClick);
                // Adiciona o novo ouvinte de evento
                button.addEventListener('click', handleRouteButtonClick);
            });
        }

        // Função que lida com o clique no botão de rota
        function handleRouteButtonClick(e) {
            e.preventDefault(); 
            
            if (!userLocation) {
                // Alerta quando não há localização para traçar rota
                alert("Não conseguimos determinar sua localização atual para traçar a rota. Por favor, recarregue a página e permita o acesso à sua localização.");
                return;
            }

            const destLat = parseFloat(this.dataset.lat);
            const destLng = parseFloat(this.dataset.lng);
            const destination = L.latLng(destLat, destLng);

            // Remove a rota anterior, se houver
            if (routingControl) {
                map.removeControl(routingControl); 
            }

            // Cria e adiciona a nova rota do userLocation (real ou fallback) para o abrigo
            routingControl = L.Routing.control({
                waypoints: [
                    userLocation, 
                    destination   
                ],
                router: L.routing.osrmv1({
                    serviceUrl: 'https://router.project-osrm.org/route/v1' 
                }),
                lineOptions: {
                    styles: [{color: '#ff7eb3', opacity: 0.8, weight: 6}] 
                },
                showAlternatives: false,
                addWaypoints: false, 
                draggableWaypoints: false, 
                fitSelectedRoutes: true, 
                createMarker: function() { return null; } 
            }).addTo(map); 
        }
    </script>
</body>
</html